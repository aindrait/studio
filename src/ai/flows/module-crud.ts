
'use server';

/**
 * @fileOverview Module CRUD operations using a file-based JSON database.
 */

import { ai } from '@/ai/genkit';
import { z } from 'zod';
import { Module, Category, Version, AdminUser } from '@/lib/types';
import fs from 'fs/promises';
import path from 'path';
import { login } from '@/lib/session';


const CategorySchema = z.object({
  name: z.string(),
});

const AdminUserSchema = z.object({
    id: z.string(),
    username: z.string(),
    password: z.string().optional(),
    role: z.enum(['admin', 'editor']),
});

// Schema for creating a new user, ID is generated by the flow.
const CreateAdminUserSchema = AdminUserSchema.omit({ id: true });
type CreateAdminUser = z.infer<typeof CreateAdminUserSchema>;


// Define the structure of our database
const DbSchema = z.object({
  modules: z.array(z.any()), // Using any for now to avoid schema duplication, will be validated on use
  categories: z.array(CategorySchema),
  users: z.array(AdminUserSchema),
});

type Db = z.infer<typeof DbSchema>;

const dbPath = path.join(process.cwd(), 'src', 'lib', 'db.json');

// Helper function to read the database file
async function readDb(): Promise<Db> {
  try {
    const fileContent = await fs.readFile(dbPath, 'utf-8');
    // Add validation here to ensure the data matches the schema
    const jsonData = JSON.parse(fileContent);
    return DbSchema.parse(jsonData);
  } catch (error) {
    // If the file doesn't exist or is empty, return a default structure
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return { modules: [], categories: [], users: [] };
    }
    console.error("Error reading or parsing database file:", error);
    throw new Error("Could not read from database.");
  }
}

// Helper function to write to the database file
async function writeDb(data: Db): Promise<void> {
  try {
    // Also validate data before writing
    const validatedData = DbSchema.parse(data);
    await fs.writeFile(dbPath, JSON.stringify(validatedData, null, 2), 'utf-8');
  } catch (error) {
    console.error("Error writing to database file:", error);
    throw new Error("Could not write to database.");
  }
}


const ModuleSchema = z.object({
  id: z.string(),
  name: z.string(),
  category: z.string(),
  tags: z.array(z.string()),
  description: z.string(),
  content: z.string(),
  image: z.string().optional(),
  versions: z.array(z.object({
    version: z.string(),
    date: z.string(),
    changes: z.array(z.object({
      type: z.enum(["new", "improvement", "fix"]),
      description: z.string(),
    })),
  })),
});


// User Flows
export const loginUserFlow = ai.defineFlow({
    name: 'loginUserFlow',
    inputSchema: z.object({ username: z.string(), password: z.string() }),
    outputSchema: AdminUserSchema.omit({ password: true }).optional(),
}, async ({ username, password }) => {
    const db = await readDb();
    const user = db.users.find(u => u.username === username && u.password === password);
    if (user) {
        await login({ username: user.username });
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { password, ...userWithoutPassword } = user;
        return userWithoutPassword;
    }
    return undefined;
});

export const getAdminUsersFlow = ai.defineFlow({
    name: 'getAdminUsersFlow',
    inputSchema: z.void(),
    outputSchema: z.array(AdminUserSchema.omit({ password: true })),
}, async () => {
    const db = await readDb();
    return db.users.map(u => {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { password, ...userWithoutPassword } = u;
        return userWithoutPassword;
    });
});

export const createAdminUserFlow = ai.defineFlow({
    name: 'createAdminUserFlow',
    inputSchema: CreateAdminUserSchema,
    outputSchema: AdminUserSchema.omit({ password: true }),
}, async (newUser) => {
    const db = await readDb();
    if (db.users.some(u => u.username === newUser.username)) {
        throw new Error('Username already exists.');
    }
    const userWithId = { ...newUser, id: `user-${Date.now()}` };
    db.users.push(userWithId);
    await writeDb(db);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { password, ...userWithoutPassword } = userWithId;
    return userWithoutPassword;
});

export const updateAdminUserFlow = ai.defineFlow({
    name: 'updateAdminUserFlow',
    inputSchema: AdminUserSchema,
    outputSchema: AdminUserSchema.omit({ password: true }).optional(),
}, async (userData) => {
    const db = await readDb();
    const index = db.users.findIndex(u => u.id === userData.id);
    if (index !== -1) {
        const existingUser = db.users[index];
        // Only update password if a new one is provided
        const newPassword = userData.password ? userData.password : existingUser.password;
        db.users[index] = { ...existingUser, ...userData, password: newPassword };
        await writeDb(db);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { password, ...userWithoutPassword } = db.users[index];
        return userWithoutPassword;
    }
    return undefined;
});

export const deleteAdminUserFlow = ai.defineFlow({
    name: 'deleteAdminUserFlow',
    inputSchema: z.string(), // user id
    outputSchema: z.boolean(),
}, async (id) => {
    const db = await readDb();
    if (id === 'user-root') {
        throw new Error('Cannot delete root admin user.');
    }
    const index = db.users.findIndex(u => u.id === id);
    if (index !== -1) {
        db.users.splice(index, 1);
        await writeDb(db);
        return true;
    }
    return false;
});


export const getModulesFlow = ai.defineFlow(
  {
    name: 'getModulesFlow',
    inputSchema: z.void(),
    outputSchema: z.array(ModuleSchema),
  },
  async () => {
    const db = await readDb();
    return db.modules;
  }
);

export const getModuleFlow = ai.defineFlow(
  {
    name: 'getModuleFlow',
    inputSchema: z.string(),
    outputSchema: ModuleSchema.optional(),
  },
  async (id) => {
    const db = await readDb();
    return db.modules.find(m => m.id === id);
  }
);

export const createModuleFlow = ai.defineFlow(
  {
    name: 'createModuleFlow',
    inputSchema: ModuleSchema,
    outputSchema: ModuleSchema,
  },
  async (module) => {
    const db = await readDb();
    db.modules.push(module);
    await writeDb(db);
    return module;
  }
);

export const updateModuleFlow = ai.defineFlow(
  {
    name: 'updateModuleFlow',
    inputSchema: ModuleSchema,
    outputSchema: ModuleSchema.optional(),
  },
  async (module) => {
    const db = await readDb();
    const index = db.modules.findIndex(m => m.id === module.id);
    if (index !== -1) {
      db.modules[index] = module;
      await writeDb(db);
      return module;
    }
    return undefined;
  }
);

export const deleteModuleFlow = ai.defineFlow(
  {
    name: 'deleteModuleFlow',
    inputSchema: z.string(), // module id
    outputSchema: z.boolean(),
  },
  async (id) => {
    const db = await readDb();
    const index = db.modules.findIndex(m => m.id === id);
    if (index !== -1) {
      db.modules.splice(index, 1);
      await writeDb(db);
      return true;
    }
    return false;
  }
);


export const getCategoriesFlow = ai.defineFlow({
    name: 'getCategoriesFlow',
    inputSchema: z.void(),
    outputSchema: z.array(CategorySchema),
}, async () => {
    const db = await readDb();
    return db.categories;
});

export const createCategoryFlow = ai.defineFlow({
    name: 'createCategoryFlow',
    inputSchema: CategorySchema,
    outputSchema: CategorySchema,
}, async (category) => {
    const db = await readDb();
    if (db.categories.some(c => c.name === category.name)) {
        throw new Error(`Category "${category.name}" already exists.`);
    }
    db.categories.push(category);
    await writeDb(db);
    return category;
});

export const updateCategoryFlow = ai.defineFlow({
    name: 'updateCategoryFlow',
    inputSchema: z.object({ oldName: z.string(), newName: z.string() }),
    outputSchema: z.string(),
}, async ({ oldName, newName }) => {
    const db = await readDb();
    const index = db.categories.findIndex(c => c.name === oldName);
    if (index === -1) {
        throw new Error(`Category "${oldName}" not found.`);
    }
    if (db.categories.some(c => c.name === newName) && oldName !== newName) {
      throw new Error(`Category "${newName}" already exists.`);
    }
    db.categories[index].name = newName;
    // also update modules
    db.modules.forEach(module => {
        if (module.category === oldName) {
            module.category = newName;
        }
    });
    await writeDb(db);
    return newName;
});


export const deleteCategoryFlow = ai.defineFlow({
    name: 'deleteCategoryFlow',
    inputSchema: z.string(),
    outputSchema: z.boolean(),
}, async (name) => {
    const db = await readDb();
    const isUsed = db.modules.some(m => m.category === name);
    if (isUsed) {
        throw new Error(`Category "${name}" is in use and cannot be deleted.`);
    }
    const index = db.categories.findIndex(c => c.name === name);
    if (index !== -1) {
        db.categories.splice(index, 1);
        await writeDb(db);
        return true;
    }
    return false;
});

export const reorderCategoriesFlow = ai.defineFlow({
    name: 'reorderCategoriesFlow',
    inputSchema: z.array(CategorySchema),
    outputSchema: z.boolean(),
}, async (categories) => {
    const db = await readDb();
    db.categories = categories;
    await writeDb(db);
    return true;
});


// Exported functions that components will call
export async function getModules(): Promise<Module[]> {
    return await getModulesFlow();
}

export async function getModule(id: string): Promise<Module | undefined> {
    return await getModuleFlow(id);
}

export async function createModule(module: Module): Promise<Module> {
    return await createModuleFlow(module);
}

export async function updateModule(module: Module): Promise<Module | undefined> {
    return await updateModuleFlow(module);
}

export async function deleteModule(id: string): Promise<boolean> {
    return await deleteModuleFlow(id);
}

export async function getCategories(): Promise<Category[]> {
    return await getCategoriesFlow();
}

export async function createCategory(category: Category): Promise<Category> {
    return await createCategoryFlow(category);
}

export async function updateCategory(oldName: string, newName: string): Promise<string> {
    return await updateCategoryFlow({ oldName, newName });
}

export async function deleteCategory(name: string): Promise<boolean> {
    return await deleteCategoryFlow(name);
}

export async function reorderCategories(categories: Category[]): Promise<boolean> {
    return await reorderCategoriesFlow(categories);
}

export async function loginUser(username: string, password: string):Promise<Omit<AdminUser, 'password'> | undefined> {
    return await loginUserFlow({ username, password });
}

export async function getAdminUsers(): Promise<Omit<AdminUser, 'password'>[]> {
    return await getAdminUsersFlow();
}

export async function createAdminUser(user: CreateAdminUser): Promise<Omit<AdminUser, 'password'>> {
    return await createAdminUserFlow(user);
}

export async function updateAdminUser(user: AdminUser): Promise<Omit<AdminUser, 'password'> | undefined> {
    return await updateAdminUserFlow(user);
}

export async function deleteAdminUser(id: string): Promise<boolean> {
    return await deleteAdminUserFlow(id);
}
